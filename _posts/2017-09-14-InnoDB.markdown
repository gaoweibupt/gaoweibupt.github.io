---
lyout:      post
title:      "InnoDB"
subtitle:   "InnoDB学习笔记"
date:       2017-09-14 16:14:00
author:     "galway"
header-img: "img/home-bg-o.jpg"
catalog:  ture
tags:
    - sql
    - 数据库
    - InnoDB
---



## 表

### 存储结构
InnoDB引擎中所有数据都被逻辑地存放在表空间中，表空间由段(segment)、区(extent)、页(page)组成。

#### 表空间
表空间有两种:共享表空间和独立表空间, 由innodb_file_per_table参数来确定是否开启独立表空间。

* 独立表空间只存放数据、索引和插入缓冲页Bitmap页，可以实现单表在不同数据库中的移动，但是独立表空间大小不能自适应扩展。
* 共享表空间的大小可以自适应扩展，但是当表删除操作较多时空间会出现大量空隙

#### 段
InnoDB引擎中段的管理是由引擎来完成的，常见的段有数据段、索引段、回滚段等。
数据段为B+树的叶子节点；
索引段为B+树的非索引节点；

#### 区
区由连续的64个页组成，每个页默认大小16KB，因此每个区大小为1MB。页的大小可以变动，但是区的大小始终为1MB。
是先使用32个碎片页，然后再进行区的申请

#### 页
页是InnoDB磁盘管理的最小单位。常见的页类型有:

* 数据页(B-tree Node)
* undo页(undo Log Page)
* 系统页(System Page)
* 事务数据页(Transaction systemn Page)
* 插入缓冲位图页(Insert Buffer Bitmap)
* 插入缓冲空闲列表页(Insert Buffer Free List)
* 未压缩的二进制大对象页(Uncompressed BLOB Page)
* 压缩的二进制大对象页(compressed BLOB Page)

B+树索引并不能找到一条具体的记录，能找到的只是记录所在的页。然后将页加载到内存，进行二分查找。

#### 行
InnoDB存储引擎是面向列的，数据是按行存储的。每个页最多允许存放16KB/2-200行记录。
行记录有下面的格式:

* Compact: 一个页中存放的数据越多，其性能越高
* Redundant: CHAR类型NULL会占用较多空间
* Compressed和Dynamic: 对于行溢出存储的数据进行了压缩

### 约束

#### 数据完整性
数据完整性有以下三种形式：

* 实体完整性保证表中只有一个主键
* 域完整性保证数据每列的值满足特定的条件
* 参照完整性保证两张表之间的关系

对于InnoDB，提供了以下几种约束：
* Primary Key
* Unique Key
* Foreign Key
* Default
* NOT NULL

#### 触发器约束
触发器的作用是在执行INSERT、DELETE、UPDATE命令之前或之后自动调用SQL命令或存储过程
不建议用触发器,触发器对表的每一行都会处理一个事务;业务也不容易跟踪

#### 外键约束

### 视图
视图中的存储没有实际的物理存储

### 分区表
可以通过分区提高MYSQL的执行效率，但是有时会适得其反。这跟数据库的应用类型有关系，数据库主要有两种应用：
* OLTP，在线事务处理
* OLAP，在线分析处理

对于OLAP分区可以提高查询性能，而OLTP需要小心应用


## 索引
B+树索引分为聚集索引和辅助索引。InnoDB引擎只支持B+树索引。

### 聚集索引
聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点成为数据页。

### 辅助索引
叶子节点并不包含行记录的全部数据。每个叶子的索引行中包含一个书签，书签就是相应行数据的聚集索引键。
用户可以设置对整个列的数据进行索引，也可以索引一个列的开头部分数据。

### 索引的使用
* 联合索引
* 覆盖索引，FORCE INDEX关键字可以强制使用某个索引

### 全文索引
全文索引是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。
InnoDB存储引擎每张表只能有一个全文检索的索引
由多列组合而成的全文检索的索引列必须使用相同的字符集和排序规则
mysql数据库通过MATCH() ... AGAINST()语法支持全文索引的查询，MATCH指定了需要被查询的列，AGINST指定了使用何种方法去进行查询

## 锁
锁机制是为了管理对共享资源的并发访问。
锁的类型:

* 共享锁(S Lock)
* 排他锁(X Lock)
* 意向锁(Intention Lock):将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁;InnoDb中意向锁即为表级别的锁。

#### 一致性非锁定读
两种事务模式：
* READ COMMITED:对于快照数据,非一致性读总是读取被锁定行的最新一份快照数据
* REPEATABLE READ:对于快照数据,非一致性读总是读取事务开始时的行数据版本

#### 一致性锁定读
用户有时需要显式地对数据库进行加锁以保证数据逻辑的一致性，有两种语句
SELECT……FOR UPDATE  加X锁
SELECT……LOCK IN SHARE MODE  加S锁

#### 自增长与锁
自增长值的列必须是索引,同时必须是索引的第一个列

### 锁的算法
InnoDB存储引擎有3种行锁的算法:
* Record Lock:单个行记录上的锁,会锁住索引记录
* Gap Lock:间隙锁,锁定一个范围,但不包含记录本身,为了阻止
* Next-Key Lock: Gap Lock + Record Lock,锁定一个范围,并且锁定记录本身

### 锁问题
#### 脏读
脏读是指在不同的事务下,当前事务可以读到另外事务未提交的数据

#### 不可重复读
不可重复读是指在一个事务内多次读取同一数据集合。脏读是读到未提交的数据,而不可重复读读到的却是已经提交的数据,但是其违反了数据库事务一致性的要求。

#### 丢失更新
一个事务的更新操作会被另一个事务的更新操作所覆盖,从而导致数据的不一致。

#### 阻塞
在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源,这就是阻塞。
在默认情况下InnoDB存储引擎不会回滚超时引发的错误异常。

#### 死锁
死锁是指两个或两个以上的事务在执行过程中,因争夺锁资源而造成的一种互相等待的现象。
解决死锁最简单的一种方法是超时,即两个事务互相等待时,当一个等待时间超过设置的某一阈值时,其中一个事务进行回滚,另一个等待的事务就能继续进行。
另一种方法是等待图,通过锁的信息链表和事务等待链表构造出一张图,在这张图中若存在回路,就代表存在死锁。

## 事务
InnoDB存储引擎中的事务完全符合ACID的特性:

* 原子性(atomicity)
* 一致性(consistency)
* 隔离性(isolation)
* 持久性(durability)








